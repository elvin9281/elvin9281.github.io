<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Garlic Notes</title><link>https://elvin9281.github.io/</link><description>Recent content in Introduction on Garlic Notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 28 Sep 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://elvin9281.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a New Theme</title><link>https://elvin9281.github.io/posts/creating-a-new-theme/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/posts/creating-a-new-theme/</guid><description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>https://elvin9281.github.io/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/posts/migrate-from-jekyll/</guid><description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>(Hu)go Template Primer</title><link>https://elvin9281.github.io/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>https://elvin9281.github.io/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description></item><item><title/><link>https://elvin9281.github.io/docs/docker/concept/commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/docker/concept/commands/</guid><description>Docker &amp;amp; Container Commands # 紀錄常用的指令
Images # 查看目前 Images(不包含「Intermediate Images」) Docker 17.05+ 以後提供名為「多階段構建 (multi-stage builds)」的新功能，透過將原先流水線中的多個映像檔整合進同個 Dockerfile 內，而後續的映像檔可透過指令取得中間映像檔 (intermediate image) 所產生的檔案 (artifacts)，如此便能讓整個過程更為簡單，也確保流水線簡潔易懂及提高維護性
docker images // or docker image ls 查看目前 Images(含「Intermediate Images」) docker images -a // or docker image ls -a 只列出所有 Images 的 ID(不含「Intermediate Images」) docker images -q // or docker image ls -q 只列出所有 Images 的 ID(含「Intermediate Images」) docker images -qa // or docker image ls -qa 建立一個名稱為 busybox 的 Image -i : Interactive，Keep STDIN open even if not attached \n -t : Allocate a pseudo-TTY docker create -it --name busybox busybox 強制刪 Docker Image (用 ID) docker rmi -f &amp;lt;Image_ID&amp;gt; 強制刪除所有 docker images(含「Intermediate Images」) docker rmi -f $(docker images -q) Container # 自動執行 docker pull(若 Local 無該 Image)，啟動並進入背景執行 -d : Run container in background and print container ID</description></item><item><title/><link>https://elvin9281.github.io/docs/linux/basic/commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/linux/basic/commands/</guid><description>Commands # 紀錄常用的指令
tar for .tar.gz # 壓縮： tar zcvf FileName.tar.gz DirName 解壓縮： tar zxvf FileName.tar.gz screen # 開啟一個互動式的 Shell screen Detach 互動式的 Shell Crtl + A + d 列所有 互動式的 Shell(會列出 Session ID) screen -ls Attach 到互動式的 Shell screen -r screen -r + SessionID 結束 互動式的 Shell exit uname - Get Kernel Version # uname -a 4 : Kernel version 19 : Major revision 0 : Minor revision 17 : Patch level or number</description></item><item><title/><link>https://elvin9281.github.io/docs/linux/basic/file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/linux/basic/file/</guid><description>File # File relationed commands
Redirecting the content of a file to the command &amp;quot;echo&amp;quot; # echo &amp;#34;$(cat my_file.txt)&amp;#34;</description></item><item><title/><link>https://elvin9281.github.io/docs/linux/basic/redirect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/linux/basic/redirect/</guid><description>Redirection (&amp;lt;, &amp;gt;, &amp;raquo;) # 在 ShellScript 內 使用 exec 做 「永久性 Redirection」 # 在 XXX.sh 中，所有stdout &amp;amp; stderr 都會導到 /path/logfile 使用 exec 命令可以永久性地重定向，後續命令的輸入輸出方向也被確定了，直到再次遇到 exec 命令才會改變重定向的方向；換句話說，一次重定向，永久有效。 XXX.sh #!/bin/bash -x exec &amp;amp;&amp;gt;&amp;gt; /path/logfile Redirection 基本概念 # Shell 提供「可以取得任一執行中的程式，再更改 取得輸入 或 產生輸出 的方式，而 不必修改程式本身」
執行handywork，輸入是名為「data.in」的檔案，輸出到名為「result.out」的檔案 # handywork &amp;lt; data.in &amp;gt; result.out 把執行handywork的錯誤導到名為 err.msgs 的檔案 # 檔案描述符：stdin：0, stdout：1, stderr：2
handywork &amp;lt; data.in &amp;gt; result.out 2&amp;gt; err.</description></item><item><title/><link>https://elvin9281.github.io/docs/linux/basic/vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/linux/basic/vim/</guid><description>vim - Editor # 一般指令模式 (command mode) # 選取 單字：v 整行：shift+v 複製選取後，按 y
貼上將剛剛複製的內容在想貼上的地方，按 p
刪除選取後，按 d
復原上一步按 u
重做上一步Ctrl + r
搜尋按 / ，若想繼續搜尋，按 n
移至檔尾（最後一行的第一個非空白字元處）按 G
移至檔首（第一行之第一個非空白字元處）按 gg
移至當行行首按 0
移至當行行尾按 $
前往特定行數: + 行數
前往成對的括號 ([{}])、/* */按 %</description></item><item><title/><link>https://elvin9281.github.io/docs/linux/network/brctl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/linux/network/brctl/</guid><description>brctl - ethernet bridge administration # Create New Ethernet Bridge brctl addbr br0 Display Available Bridge brctl show Delete Existing Bridge brctl delbr br0 Add an Interface/Multiple Interfaces to Existing Bridge brctl addif br0 eth0 eth1 Tracking MAC address of a Bridge brctl showmacs br0 Enable/Disable Spanning Tree on Ethernet Bridge # Enable brctl stp br0 on # Disable brctl stp br0 off Display STP Parameter Values of a Bridge brctl showstp br0</description></item><item><title/><link>https://elvin9281.github.io/docs/linux/network/curl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/linux/network/curl/</guid><description>curl - 與 Server 間傳輸資料的工具，支援多種協定(HTTP, HTTPS, SCP, TELNET, 等等 ) # -k: 略過檢查自簽 SSL 憑證有效性 $ curl -k https://domainname</description></item><item><title/><link>https://elvin9281.github.io/docs/linux/shell/string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://elvin9281.github.io/docs/linux/shell/string/</guid><description>Strings # Remove first and last quote (&amp;quot;) from a variable # 's/^&amp;quot;//'replaces a leading &amp;quot; with nothing 's/&amp;quot;$//'replaces a trailing &amp;quot; with nothing &amp;lt;&amp;lt;&amp;lt; : here-string Operator，string as stdin (In the same invocation ,there isn&amp;rsquo;t any need to pipe and start another sed. Using -e you can have multiple text processing).
opt=&amp;#34;\&amp;#34;html test\&amp;#34;&amp;#34; sed -e &amp;#39;s/^&amp;#34;//&amp;#39; -e &amp;#39;s/&amp;#34;$//&amp;#39; &amp;lt;&amp;lt;&amp;lt;&amp;#34;$opt&amp;#34;</description></item></channel></rss>